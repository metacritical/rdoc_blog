# frozen_string_literal: true

require 'rdoc/parser'

module RDocBlog
  module MonkeyPatch
    def self.apply
      RDoc::Parser.singleton_class.prepend(ParserExtensions)
      
      # Monkey patch RDoc::VERSION to customize the footer
      # This is a bit hacky but effective for changing the "Generated by" text
      RDoc.send(:remove_const, :VERSION)
      RDoc.const_set(:VERSION, "6.16.0 (Monkey Patched). <a href='https://ruby.github.io/rdoc/RDoc/MarkupReference.html'>Markup Reference</a>")
    end

    module ParserExtensions
      # Intercept the parser selection
      def for(top_level, content, options, stats)
        # Check if the content starts with our special Title directive
        if content =~ /\A\s*Title:\s*["'](.+?)["']/i
          title = $1
          
          # Store the title in the TopLevel metadata
          # puts "DEBUG: Setting title for #{top_level.name} to '#{title}'"
          top_level.metadata['title'] = title

          # Transform the content:
          # 1. Replace the "Title: ..." line with an RDoc header "= Title"
          # 2. This ensures RDoc treats it as the page title
          new_content = content.sub(/\A\s*Title:\s*["'].+?["']\s*/, "= #{title}\n\n")
          
          # Force usage of Simple parser (which handles RDoc format text)
          # We pass the *new* content to it
          return RDoc::Parser::Simple.new(top_level, new_content, options, stats)
        end

        # Fallback to original behavior
        super
      end
    end
  end
end

# Monkey patch RDoc::TopLevel to use the title from metadata as the name
class RDoc::TopLevel
  alias_method :original_name, :name
  alias_method :original_base_name, :base_name
  alias_method :original_page_name, :page_name

  def name
    return metadata['title'] if metadata && metadata['title']
    original_name
  end

  def base_name
    return metadata['title'] if metadata && metadata['title']
    original_base_name
  end

  def page_name
    return metadata['title'] if metadata && metadata['title']
    original_page_name
  end
end

# Monkey patch RDoc::Generator::JsonIndex to only index pages (titles/content)
# This removes Classes and Methods from the search index
require 'rdoc/generator/json_index'
class RDoc::Generator::JsonIndex
  alias_method :original_build_index, :build_index

  def build_index
    reset @store.all_files.sort, @store.all_classes_and_modules.sort

    # Only index pages, skip classes and methods
    index_pages

    { :index => @index }
  end

  def index_pages
    debug_msg "  generating pages search index"

    pages = @files.select do |file|
      file.text?
    end

    pages.each do |page|
      debug_msg "    #{page.page_name}"
      record = page.search_record
      @index[:searchIndex]     << search_string(record.shift)
      # Use the page description (content) for longSearchIndex to enable content search
      # We strip HTML tags and newlines to make it cleaner for the index
      content = page.description.gsub(/<[^>]+>/, ' ').gsub(/\s+/, ' ').strip
      @index[:longSearchIndex] << search_string(content)
      record.shift # skip original long name (empty for pages usually)
      @index[:info]            << record
    end
  end
end

# Monkey patch RDoc::Generator::Darkfish to remove Classes/Methods links from sidebar
require 'rdoc/generator/darkfish'
class RDoc::Generator::Darkfish
  alias_method :original_template_for, :template_for

  def template_for(file, page = true, klass = ERB)
    file_str = file.to_s

    if file_str.end_with?('_sidebar_navigation.rhtml')
      # Return a custom template that only includes Home and Pages
      template_str = <<-TEMPLATE
<div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="<%= rel_prefix %>/index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="<%= rel_prefix %>/table_of_contents.html#pages">Pages</a>
  </div>
</div>
      TEMPLATE
      
      # Fix erbout logic: 
      # If page is true (full page), use 'io' (standard Darkfish behavior)
      # If page is false (partial), use '_erbout_...' (standard Darkfish behavior)
      if page
        erbout = 'io'
      else
        erbout = "_erbout_sidebar_navigation"
      end
      
      return klass.new(template_str, trim_mode: '-', eoutvar: erbout)
    end

    if file_str.end_with?('_sidebar_search.rhtml')
      # Return a custom template with updated placeholder
      template_str = <<-TEMPLATE
<div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search posts..." spellcheck="false"
             autocomplete="off"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>
      TEMPLATE

      if page
        erbout = 'io'
      else
        erbout = "_erbout_sidebar_search"
      end

      return klass.new(template_str, trim_mode: '-', eoutvar: erbout)
    end

    # Aliki specific patches
    if file_str.end_with?('_header.rhtml')
      # Patch Aliki header to update search placeholder
      template_str = <<-TEMPLATE
<header class="top-navbar">
  <a href="<%= rel_prefix %>/index.html" class="navbar-brand">
    <%= h @options.title %>
  </a>

  <!-- Desktop search bar -->
  <div class="navbar-search navbar-search-desktop" role="search">
    <form action="#" method="get" accept-charset="utf-8">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search posts..."
             spellcheck="false" autocomplete="off"
             title="Type to search, Up and Down to navigate, Enter to load">
      <ul id="search-results" aria-label="Search Results"
          aria-busy="false" aria-expanded="false"
          aria-atomic="false" class="initially-hidden"></ul>
    </form>
  </div>

  <!-- Mobile search icon button -->
  <button id="search-toggle" class="navbar-search-mobile" aria-label="Open search" type="button">
    <span aria-hidden="true">üîç</span>
  </button>

  <!-- Theme toggle button -->
  <button id="theme-toggle" class="theme-toggle" aria-label="Switch to dark mode" type="button">
    <span class="theme-toggle-icon" aria-hidden="true">üåô</span>
  </button>
</header>

<!-- Search Modal (Mobile) -->
<div id="search-modal" class="search-modal" hidden aria-modal="true" role="dialog" aria-label="Search">
  <div class="search-modal-backdrop"></div>
  <div class="search-modal-content">
    <div class="search-modal-header">
      <form class="search-modal-form" action="#" method="get" accept-charset="utf-8">
        <span class="search-modal-icon" aria-hidden="true">üîç</span>
        <input id="search-field-mobile" role="combobox" aria-label="Search"
               aria-autocomplete="list" aria-controls="search-results-mobile"
               type="text" name="search" placeholder="Search posts..."
               spellcheck="false" autocomplete="off">
        <button type="button" class="search-modal-close" aria-label="Close search" id="search-modal-close">
          <span aria-hidden="true">esc</span>
        </button>
      </form>
    </div>
    <div class="search-modal-body">
      <ul id="search-results-mobile" aria-label="Search Results"
          aria-busy="false" aria-expanded="false"
          aria-atomic="false" class="search-modal-results initially-hidden"></ul>
      <div class="search-modal-empty">
        <p>No recent searches</p>
      </div>
    </div>
  </div>
</div>
      TEMPLATE

      if page
        erbout = 'io'
      else
        erbout = "_erbout_header"
      end

      return klass.new(template_str, trim_mode: '-', eoutvar: erbout)
    end

    if file_str.end_with?('_sidebar_classes.rhtml')
      # Patch Aliki sidebar classes to be empty
      template_str = ""
      
      if page
        erbout = 'io'
      else
        erbout = "_erbout_sidebar_classes"
      end

      return klass.new(template_str, trim_mode: '-', eoutvar: erbout)
    end

    if file_str.end_with?('table_of_contents.rhtml')
      # Return a custom template that only includes Pages
      template_str = <<-TEMPLATE
<body id="top" class="table-of-contents">
<%= render '_sidebar_toggle.rhtml' %>

<nav id="navigation" role="navigation">
  <div id="project-navigation">
    <%= render '_sidebar_navigation.rhtml' %>

    <%= render '_sidebar_search.rhtml' %>
  </div>

  <%= render '_footer.rhtml' %>
</nav>
<main role="main">
<h1 class="class"><%= h @title %></h1>

<%- simple_files = @files.select { |f| f.text? } %>
<%- unless simple_files.empty? then %>
<h2 id="pages">Pages</h2>
<ul>
<%- simple_files.sort.each do |file| %>
  <li class="file">
    <a href="<%= h file.path %>"><%= h file.page_name %></a>
<%
   # HACK table_of_contents should not exist on Document
   table = file.parse(file.comment).table_of_contents
   unless table.empty? then %>
    <ul>
    <%- table.each do |heading| %>
      <li><a href="<%= h file.path %>#<%= heading.aref %>"><%= heading.plain_html %></a></li>
    <%- end %>
    </ul>
<%- end %>
  </li>
  <%- end %>
</ul>
<%- end %>

</main>
</body>
      TEMPLATE

      if page
        erbout = 'io'
      else
        erbout = "_erbout_table_of_contents"
      end

      return klass.new(template_str, trim_mode: '-', eoutvar: erbout)
    end

    original_template_for(file, page, klass)
  end
end
